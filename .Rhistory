2+1
source("https://bioconductor.org/biocLite.R")
install.packages("install.packages("ggplot2")")
install.packages(c("install.packages("", "ggplot2", "")"))
install.packages("install.packages('ggplot2')")
install.packages("install.packages("ggplot2")")
install.packages("install.packages("ggplot2")")
install.packages("install.packages("plot3D")")
install.packages(c("install.packages('ggplot2'", "dep", "=", "TRUE)"))
install.packages("install.packages('ggplot2')")
install.packages("install.packages('ggplot2')")
install.packages("install.packages('ggplot2')")
install.packages("ggplot2")
sessionInfo()
install.packages("install.load('KernSmooth')")
install.load('KernSmooth')
install.packages('KernSmooth')
library('KernSmooth')
hello
** babu**
load("F:/r git/jaka/README.md")
load("F:/r git/jaka/ha.Rmd")
swirl()
swirl()
swirl()
library("swirl")
swirl()
6<7
10<=10
5!=7
!(5==7)
FALSE & FALSE 
TRUE & c(TRUE, FALSE, FALSE)
TRUE && c(TRUE, FALSE, FALSE)
TRUE | c(TRUE, FALSE, FALSE)
TRUE || c(TRUE, FALSE, FALSE)
5 > 8 || 6 != 8 && 4 > 3.9
isTRUE(6 > 4)
identical('twins', 'twins')
xor(5
| == 6, !FALSE)
xor(5==6,!FALSE)
ints<- sample(10)
ints
ints>5
which(int>7)
which(ints>7)
any(ints<0)
all(ints>0)
Sys.Date()
mean(c(2,4,5))
boring_function <- function(x) {
  #x
}
boring_function <- function(x) {
  x
}
submit()
submit()
 boring_function('My first function!')
boring_function 
submit()
submit()
my_mean(c(4,5,10))
submit()
submit()
submit()
remainder(5)
remainder(11,5)
remainder(divisor=11,num=5)
remainder(4, div = 2)
args(remainder)
submit()
evaluate(c(1.4, 3.6, 7.9, 8.8))
evaluate(sd,c(1.4, 3.6, 7.9, 8.8))
evaluate(function(x){x+1}, 6)
evaluate(anonymous(x){x[1]},c(8,4,0))
evaluate(anonymous(x){x[[1]]},c(8,4,0))
evaluate(anonymous(x)x[1],c(8,4,0))
evaluate(function(x){x[1]}, c(8,4,0)
evaluate(function(x){x[1]}, c(8,4,0)
evaluate(function(x){x[1]}, c(8,4,0))
evaluate(function(x){x[length(x)]}, c(8,4,0))
?paste
paste("Programming", "is", "fun!")
submit()
telegram("I","am","mad")
bye()
q()
ls()
load("C:\\Users\\Vikarn Saraswat\\Documents\\.RData")
ls()
clear
clear()
q()
load(swirl)
load("swirl")
library(swirl)
swirl()
head(flags)
dim(flags)
class(flags)
cls_list <- lapply(flags, class)
cls_list 
class(cls_list)
as.character(cls_list)
cls_vect<-sapply(flags,class)
class(cls_vector)
class(cls_vect)
sum(flags$orange)
flag_colors <- flags[11:17] 
flag_colors <- flags[,11:17] 
head(flag_colors)
lapply(flag_colors,sum)
sapply(flag_colors,sum)
sapply(flag_colors,mean)
flag_shapes <- flags[, 19:23]
lapply(flag_shapes,range)
sapply(flag_shapes,range)
shape_mat<-sapply(flag_shapes,range)
head(shap_mat)
head(shape_mat)
shape_mat
class(shape_mat)
unique(c(3, 4, 5, 5, 5, 6,6))
unique_vals<-lapply(flags,unique)
unique_vals
sapply(unique_vals,length)
sapply(flags,length)
sapply(flags,unique)
lapply(unique_vals, function(elem) elem[2])
sapply(flags,unique)
vapply(flags, unique, numeric(1))
ok()
sapply(flags, class)
vapply(flags, class, character(1))
?tapply
table(flags$landmass)
table(flags$animate)
tapply(flags$animate, flags$landmass, mean)
tapply(flags$population, flags$red, summary)
tapply(flags$population, flags$landmass, summary)
q()
library(datasets)
data(iris)
iris
sapply(iris$Sepal.Length ,2,mean)
sapply(iris$Sepal.Length ,mean)
sapply(sapply(iris$Sepal.Length ,mean),mean)
apply(iris$Sepal.Length,2 ,mean)
apply(iris$Sepal.Length,1 ,mean)
apply(iris,2 ,mean)
factors(iris$Species)
factor(iris$Species)
tapply(iris$Sepal.Length,factor(iris$Species) ,mean)
tapply(iris$Sepal.Length,factor(iris$Species)="virginica " ,mean)
tapply(iris$Sepal.Length,factor(iris$Species)[3] ,mean)
tapply(iris$Sepal.Length,factor(iris$Species),mean)
factor(iris)
colMeans(iris)
rowMeans(iris[,1:4])
apply(iris,2,mean)
apply(iris,1,mean)
apply(iris[,1:4],1,mean)
apply(iris[,1:4],2,mean)
data(mtcars)
mtcars
sapply(split(mtcars$mpg,mtcars$cyl),mean)
lapply(mtcars,mean)
mean(mtcars$mpg,mtcars$cyl)
with(mtcars,tapply(mpg,cyl,mean))
with(mtcars,tapply(hp,cyl,mean))
h<-209.21429 -82.63636 
h
debug(ls)
is
q()
?solve
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## makeCache matrix will search for inverse named function if it exhist it will 
## be stored in m and will be utilized as per requirement otherwise it  
makeCacheMatrix <- function(x = matrix()) {
        m <- NULL
        set <- function(y) {
                x <<- y
                m <<- NULL
        }
        get <- function(){
x
  }
        setinverse <- function(inverse) {
m <<-inverse
  }
        getinverse <- function(){
 m
  }
        list(set = set, get = get,
             setinverse = setinverse,
             getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
m <- x$getmean()
        if(!is.null(m)) {
                message("getting cached data")
                return(m)
        }
        data <- x$get()
        m <- solve(x)
        x$setinverse(m)
        m
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
m$get()
m%*%x
m$get()%*%x
cacheSolve(m)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## makeCache matrix will search for inverse named function if it exhist it will 
## be stored in m and will be utilized as per requirement otherwise it  
makeCacheMatrix <- function(x = matrix()) {
        m <- NULL
        set <- function(y) {
                x <<- y
                m <<- NULL
        }
        get <- function(){
x
  }
        setinverse <- function(inverse) {
m <<-inverse
  }
        getinverse <- function(){
 m
  }
        list(set = set, get = get,
             setinverse = setinverse,
             getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
        if(!is.null(m)) {
                message("getting cached data")
                return(m)
        }
        data <- x$get()
        m <- solve(x)
        x$setinverse(m)
        m
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
 m$get()
cacheSolve(m)
solve(x)
cacheSolve(m)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## makeCache matrix will search for inverse named function if it exhist it will 
## be stored in m and will be utilized as per requirement otherwise it  
makeCacheMatrix <- function(x = matrix()) {
        m <- NULL
        set <- function(y) {
                x <<- y
                m <<- NULL
        }
        get <- function(){
x
  }
        setinverse <- function(inverse) {
m <<-inverse
  }
        getinverse <- function(){
 m
  }
        list(set = set, get = get,
             setinverse = setinverse,
             getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
  m <- x$getinverse()
        if(!is.null(m)) {
                message("getting cached data")
                return(m)
        }
        data <- x$get()
        m <- solve(data)
        x$setinverse(m)
        m
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
cacheSolve(m)
cacheSolve(m)
x%*%solve(x)
q()
q()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
## makeCache matrix will search for inverse, if it exhist it will 
## be stored in m and will be utilized as per requirement otherwise it  
makeCacheMatrix <- function(x = matrix()) {
        m <- NULL
        set <- function(y) {
                x <<- y
                m <<- NULL
        }
        get <- function(){
x
  }
        setinverse <- function(inverse) {
m <<-inverse
  }
        getinverse <- function(){
 m
  }
        list(set = set, get = get,
             setinverse = setinverse,
             getinverse = getinverse)
}
## Write a short comment describing this function
## this function solves the inverse
cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
  m <- x$getinverse()
        if(!is.null(m)) {
                message("getting cached data")
                return(m)
        }
        data <- x$get()
        m <- solve(data)
        x$setinverse(m)
        m
}
x = rbind(c(1, -1/4), c(-1/4, 1))
 m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
q()
